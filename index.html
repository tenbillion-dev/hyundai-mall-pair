<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>í˜„ëŒ€ëª° í˜ì–´ ìë™ ë¶„ë°°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #333;
        }
        .section {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .section h2 {
            margin-bottom: 15px;
            color: #444;
            font-size: 1.2rem;
            border-bottom: 2px solid #007bff;
            padding-bottom: 8px;
        }

        /* ì…ë ¥ ì˜ì—­ */
        .input-row {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .input-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .input-group label {
            font-weight: 600;
            color: #555;
        }
        .input-group input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 1rem;
        }

        /* ìƒí’ˆ í…Œì´ë¸” */
        .product-table {
            width: 100%;
            border-collapse: collapse;
        }
        .product-table th, .product-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .product-table th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .product-table input {
            width: 100px;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .product-table .required {
            background: #fff3cd;
        }
        .product-table input:focus {
            outline: none;
            border-color: #007bff;
        }

        /* ë²„íŠ¼ */
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        /* ê²°ê³¼ ì˜ì—­ */
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }
        .person-card {
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            background: white;
        }
        .person-card.tier-50 {
            border-color: #28a745;
            background: #d4edda;
        }
        .person-card.tier-40 {
            border-color: #ffc107;
            background: #fff3cd;
        }
        .person-card.tier-30 {
            border-color: #17a2b8;
            background: #d1ecf1;
        }
        .person-card.tier-under {
            border-color: #dc3545;
            background: #f8d7da;
        }
        .person-card.completed {
            border-color: #6c757d;
            background: #e9ecef;
            opacity: 0.7;
        }
        .person-card h3 {
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .progress-badge {
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 10px;
            background: #6c757d;
            color: white;
            margin-left: 8px;
        }
        .progress-badge.done {
            background: #28a745;
        }
        .person-card .total {
            font-size: 1.1rem;
            font-weight: 700;
        }
        .person-card ul {
            list-style: none;
            font-size: 0.9rem;
        }
        .person-card li {
            padding: 5px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #eee;
        }
        .person-card li:last-child {
            border-bottom: none;
        }
        .person-card li.ordered {
            opacity: 0.5;
            text-decoration: line-through;
        }
        .person-card li.ordered .order-check {
            background: #28a745;
            border-color: #28a745;
            color: white;
        }
        .order-check {
            width: 22px;
            height: 22px;
            border: 2px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.2s;
            flex-shrink: 0;
            margin-right: 8px;
        }
        .order-check:hover {
            border-color: #28a745;
        }
        .item-info {
            display: flex;
            align-items: center;
            flex: 1;
        }
        .item-name {
            flex: 1;
        }

        /* ì¬ê³  í‘œì‹œ */
        .stock-info {
            color: #666;
            font-size: 0.85rem;
        }

        /* ìš”ì•½ */
        .summary {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        .summary-item {
            padding: 10px 20px;
            background: #e9ecef;
            border-radius: 6px;
        }
        .summary-item strong {
            display: block;
            font-size: 1.3rem;
            color: #333;
        }

        /* ì¸ì› ì²´í¬ë°•ìŠ¤ */
        .person-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .person-checkbox {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .person-checkbox:hover {
            border-color: #007bff;
        }
        .person-checkbox.selected {
            background: #007bff;
            border-color: #007bff;
            color: white;
        }
        .person-checkbox input {
            display: none;
        }

        /* ì‚¬ì… í•­ëª© ìŠ¤íƒ€ì¼ */
        .buy-item {
            background: #e8f5e9 !important;
        }
        .buy-item .item-name {
            color: #2e7d32;
        }
        .section-divider {
            text-align: center;
            color: #666;
            font-size: 0.8rem;
            padding: 8px 0 !important;
            border-bottom: none !important;
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>ğŸ›’ í˜„ëŒ€ëª° í˜ì–´ ìë™ ë¶„ë°°</h1>

    <!-- ì¸ì› ì„ íƒ -->
    <div class="section">
        <h2>ğŸ‘¥ ë¶„ë°° ëŒ€ìƒ ì„ íƒ</h2>
        <div class="person-checkboxes" id="personCheckboxes">
            <!-- JSë¡œ ë™ì  ìƒì„± -->
        </div>
        <div class="btn-group" style="margin-top: 15px;">
            <button class="btn btn-secondary" onclick="selectAllPersons()">ì „ì²´ ì„ íƒ</button>
            <button class="btn btn-secondary" onclick="deselectAllPersons()">ì „ì²´ í•´ì œ</button>
        </div>
    </div>

    <!-- ìƒí’ˆ ëª©ë¡ ë° ê°€ê²©/ì¬ê³  ì…ë ¥ -->
    <div class="section">
        <h2>ğŸ“¦ ìƒí’ˆ ëª©ë¡ (ê°€ê²©/ì¬ê³  ì…ë ¥)</h2>
        <div class="btn-group" style="margin-bottom: 15px;">
            <button class="btn btn-secondary" onclick="copyStockData()">ğŸ“‹ ì¬ê³  ë°ì´í„° ë³µì‚¬</button>
            <button class="btn btn-secondary" onclick="showPasteModal()">ğŸ“¥ ì¬ê³  ë°ì´í„° ë¶™ì—¬ë„£ê¸°</button>
        </div>
        <table class="product-table">
            <thead>
                <tr>
                    <th>ìƒí’ˆëª…</th>
                    <th>ê°€ê²© (ì›)</th>
                    <th>ìœ„íƒ</th>
                    <th>ì‚¬ì…</th>
                    <th>êµ¬ë¶„</th>
                </tr>
            </thead>
            <tbody id="productTableBody">
                <!-- JSë¡œ ë™ì  ìƒì„± -->
            </tbody>
        </table>
        <div class="btn-group">
            <button class="btn btn-primary" onclick="runDistribution()">ğŸš€ ë¶„ë°° ì‹¤í–‰</button>
            <button class="btn btn-secondary" onclick="saveToLocalStorage()">ğŸ’¾ ì €ì¥</button>
            <button class="btn btn-secondary" onclick="resetAll()">ğŸ”„ ì´ˆê¸°í™”</button>
            <button class="btn btn-secondary" onclick="clearDistribution()" style="background: #dc3545;">ğŸ—‘ï¸ ë¶„ë°° ì´ˆê¸°í™”</button>
        </div>
    </div>

    <!-- ë¶„ë°° ê²°ê³¼ -->
    <div class="section" id="resultsSection" style="display: none;">
        <h2>ğŸ“Š ë¶„ë°° ê²°ê³¼ <span id="distributionTime" style="font-size: 0.8rem; font-weight: normal; color: #666;"></span></h2>
        <div class="summary" id="summary"></div>
        <div class="results-grid" id="resultsGrid"></div>
    </div>

    <!-- ë¶™ì—¬ë„£ê¸° ëª¨ë‹¬ -->
    <div id="pasteModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
        <div style="background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 500px;">
            <h3 style="margin-bottom: 15px;">ğŸ“¥ ì¬ê³  ë°ì´í„° ë¶™ì—¬ë„£ê¸°</h3>
            <textarea id="pasteArea" style="width: 100%; height: 150px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 12px;" placeholder="ë³µì‚¬í•œ ì¬ê³  ë°ì´í„°ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”..."></textarea>
            <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="closePasteModal()">ì·¨ì†Œ</button>
                <button class="btn btn-primary" onclick="applyPastedData()">ì ìš©</button>
            </div>
        </div>
    </div>

    <script>
        // 27ëª… ê³ ì • ì¸ì›
        const persons = [
            'í™˜ì¤€', 'ìˆœë€', 'ìƒë³µ', 'ë¯¼í›„', 'ë„í˜„', 'ì˜ì˜¤', 'ì¬í˜', 'í™˜êµ­', 'ìš°ì„±',
            'ê¸°ë´‰', 'ì¤€í˜„', 'ìµì„ ', 'ì •í˜„', 'ì„±íƒœ', 'ì—°ì‹', 'ìƒí˜„', 'ì„¸ìš©', 'ë¯¼ê·œ',
            'ë³‘í˜„', 'ì„±ë²”', 'íƒœí˜‘', 'ê±´í˜¸', 'ê·œì„±', 'ìˆ˜ë¯¼', 'ì¬í›ˆ', 'ë¯¼ì œ', 'í˜•ìš±'
        ];

        // ìƒí’ˆ ë°ì´í„° (stock: ìœ„íƒ, buyStock: ì‚¬ì…)
        const products = [
            // í•„ìˆ˜ ìƒí’ˆ
            { id: 1, name: 'ë½í† í• ê³¨ë“œ 6í†µ', price: 49735, stock: 5, buyStock: 0, required: true },
            { id: 2, name: 'ë£¨ì§€ì•„ 6ë°•ìŠ¤', price: 61800, stock: 5, buyStock: 0, required: true },
            // ì¼ë°˜ ìƒí’ˆ
            { id: 3, name: 'ì˜ˆë¯¼í•œ ì¥', price: 42600, stock: 0, buyStock: 0, required: false },
            { id: 4, name: 'ë‘”ê°í•œ ì¥', price: 43096, stock: 0, buyStock: 0, required: false },
            { id: 5, name: 'ë©€í‹°ë¹„íƒ€ë¯¼', price: 48890, stock: 0, buyStock: 0, required: false },
            { id: 6, name: 'í”„ë¡œë©”ê°€ ì¥ìš©ì„± ì˜¤ë©”ê°€3', price: 78650, stock: 0, buyStock: 0, required: false },
            { id: 7, name: 'ë¹„ì—ë‚ ì”¬ í”„ë¡œ', price: 147310, stock: 0, buyStock: 0, required: false },
            { id: 8, name: 'ë¹„ì—ë‚ ì”¬ ì¼ë°˜', price: 149660, stock: 0, buyStock: 0, required: false },
            { id: 9, name: 'ë½í† í• ê³¨ë“œ 10í†µ', price: 82110, stock: 0, buyStock: 0, required: false },
            { id: 10, name: 'ë½í† í• ìŠ¬ë¦¼ 6í†µ', price: 92750, stock: 0, buyStock: 0, required: false },
            { id: 11, name: 'ë£¨í…Œì¸ 10í†µ', price: 51978, stock: 0, buyStock: 0, required: false },
            { id: 12, name: 'ë‹¥í„°ë¦° ì´ˆì„ê³„ ì˜¤ë©”ê°€3 12ê°œ', price: 79762, stock: 0, buyStock: 0, required: false },
            { id: 13, name: 'ë‹¥í„°ë¦° í•˜ì´í¼ì…€', price: 136260, stock: 0, buyStock: 0, required: false },
            { id: 14, name: 'ì¢…ê·¼ë‹¹ ë£¨í…Œì¸ ì˜¤ë©”ê°€3', price: 37575, stock: 0, buyStock: 0, required: false },
            { id: 15, name: 'ì´ˆì„ê³„ ì˜¤ë©”ê°€3 3ë°•ìŠ¤', price: 21700, stock: 10, buyStock: 0, required: false },
            { id: 16, name: 'ë½í† í• ë‹¹ì¼€ì–´', price: 50013, stock: 10, buyStock: 0, required: false },
            { id: 17, name: 'ì½˜ë“œë¡œì´ì¹œ ë§¥ìŠ¤ 3ë°•ìŠ¤', price: 48000, stock: 5, buyStock: 0, required: false },
            { id: 18, name: 'ì½˜ë“œë¡œì´ì¹œ ë§¥ìŠ¤ 5ë°•ìŠ¤', price: 71430, stock: 0, buyStock: 0, required: false },
            { id: 19, name: 'ì–‘ë°°ì¶”ì¦™', price: 34700, stock: 0, buyStock: 0, required: false },
            { id: 20, name: 'ì„ë¥˜ 11ê°œ', price: 65203, stock: 0, buyStock: 0, required: false },
            { id: 21, name: 'ì´ë„ˆí”Œë¡œë¼ 3ê°œ', price: 50513, stock: 0, buyStock: 0, required: false },
            { id: 22, name: 'í…Œí¬ 8L', price: 15800, stock: 0, buyStock: 0, required: false },
            { id: 23, name: 'ì½¤ë¹„íƒ€ ë§ˆëˆ„ì¹´ê¿€', price: 59427, stock: 0, buyStock: 0, required: false },
            { id: 24, name: 'ë¹„ë¹„ë© ì½œë¼ê²', price: 86211, stock: 0, buyStock: 0, required: false },
            { id: 25, name: 'ì…€ë ‰ìŠ¤ ë¡œìš°ìŠˆê±° 125ml x48', price: 42600, stock: 0, buyStock: 0, required: false },
            { id: 26, name: 'ì…€ë ‰ìŠ¤ ë¡œìš°ìŠˆê±° 190ml x48', price: 50140, stock: 0, buyStock: 0, required: false },
            { id: 27, name: 'í‚¤ì¹œíƒ€ì˜¬ 140ë§¤', price: 11439, stock: 0, buyStock: 0, required: false },
            { id: 28, name: 'ì •ê´€ì¥ í™ì‚¼ ì—ë¸Œë¦¬íƒ€ì„ í•„ë¦„ 60ë§¤', price: 76870, stock: 0, buyStock: 0, required: false },
            { id: 29, name: 'ëª¨ë˜ì—ë””ì…˜ ë² ìŠ¤íŠ¸', price: 99200, stock: 0, buyStock: 0, required: false },
        ];

        // ëª©í‘œ ê¸ˆì•¡ ë²”ìœ„ (min ì´ìƒ ~ max ì´í•˜) - ì ˆëŒ€ ë³€ê²½ ê¸ˆì§€!
        const TARGET_TIERS = [
            { min: 500000, max: 515000, name: '50ë§Œ', class: 'tier-50' },
            { min: 400000, max: 415000, name: '40ë§Œ', class: 'tier-40' },
            { min: 300000, max: 315000, name: '30ë§Œ', class: 'tier-30' },
        ];
        const MIN_ORDER = 50000; // ìµœì†Œ 5ë§Œì›

        // ì´ˆê¸°í™”
        function init() {
            loadFromLocalStorage();
            renderPersonCheckboxes();
            restoreSelectedPersons();
            renderProductTable();
        }

        // ì¸ì› ì²´í¬ë°•ìŠ¤ ë Œë”ë§
        function renderPersonCheckboxes() {
            const container = document.getElementById('personCheckboxes');
            container.innerHTML = '';

            persons.forEach((name, index) => {
                const label = document.createElement('label');
                label.className = 'person-checkbox selected';
                label.innerHTML = `
                    <input type="checkbox" id="person_${index}" checked onchange="togglePerson(this)">
                    <span>${name}</span>
                `;
                container.appendChild(label);
            });
        }

        // ì¸ì› í† ê¸€
        function togglePerson(checkbox) {
            const label = checkbox.parentElement;
            if (checkbox.checked) {
                label.classList.add('selected');
            } else {
                label.classList.remove('selected');
            }
        }

        // ì „ì²´ ì„ íƒ
        function selectAllPersons() {
            persons.forEach((_, index) => {
                const checkbox = document.getElementById(`person_${index}`);
                checkbox.checked = true;
                checkbox.parentElement.classList.add('selected');
            });
        }

        // ì „ì²´ í•´ì œ
        function deselectAllPersons() {
            persons.forEach((_, index) => {
                const checkbox = document.getElementById(`person_${index}`);
                checkbox.checked = false;
                checkbox.parentElement.classList.remove('selected');
            });
        }

        // ì„ íƒëœ ì¸ì› ê°€ì ¸ì˜¤ê¸°
        function getSelectedPersons() {
            const selected = [];
            persons.forEach((name, index) => {
                const checkbox = document.getElementById(`person_${index}`);
                if (checkbox && checkbox.checked) {
                    selected.push(name);
                }
            });
            return selected;
        }

        // ìƒí’ˆ í…Œì´ë¸” ë Œë”ë§
        function renderProductTable() {
            const tbody = document.getElementById('productTableBody');
            tbody.innerHTML = '';

            products.forEach(product => {
                const tr = document.createElement('tr');
                tr.className = product.required ? 'required' : '';
                tr.innerHTML = `
                    <td>${product.name}</td>
                    <td><input type="number" id="price_${product.id}" value="${product.price}" min="0" step="1000" onchange="updateProduct(${product.id})"></td>
                    <td><input type="number" id="stock_${product.id}" value="${product.stock}" min="0" onchange="updateProduct(${product.id})"></td>
                    <td><input type="number" id="buyStock_${product.id}" value="${product.buyStock}" min="0" onchange="updateProduct(${product.id})" style="background: #e8f5e9;"></td>
                    <td>${product.required ? 'â­ í•„ìˆ˜' : 'ì¼ë°˜'}</td>
                `;
                tbody.appendChild(tr);
            });
        }

        // ìƒí’ˆ ì •ë³´ ì—…ë°ì´íŠ¸
        function updateProduct(id) {
            const product = products.find(p => p.id === id);
            if (product) {
                product.price = parseInt(document.getElementById(`price_${id}`).value) || 0;
                product.stock = parseInt(document.getElementById(`stock_${id}`).value) || 0;
                product.buyStock = parseInt(document.getElementById(`buyStock_${id}`).value) || 0;
            }
        }

        // ì•„ì´ë””ë‹¹ 1ê°œ ì œí•œ ìƒí’ˆ (ID ê¸°ì¤€)
        const LIMITED_PRODUCTS = [1, 9, 2, 12]; // ë½í† í• ê³¨ë“œ 6í†µ, ë½í† í• ê³¨ë“œ 10í†µ, ë£¨ì§€ì•„ 6ë°•ìŠ¤, ë‹¥í„°ë¦° ì´ˆì„ê³„ ì˜¤ë©”ê°€3 12ê°œ

        // ë¬´ì œí•œ ìƒí’ˆ (ìµœëŒ€ 10ê°œ) - ID ê¸°ì¤€
        const UNLIMITED_PRODUCTS = [6, 3, 4, 5, 11, 14, 21, 22, 27, 10, 16];
        // í”„ë¡œë©”ê°€ ì¥ìš©ì„± ì˜¤ë©”ê°€3, ì˜ˆë¯¼í•œ ì¥, ë‘”ê°í•œ ì¥, ë©€í‹°ë¹„íƒ€ë¯¼, ë£¨í…Œì¸ 10í†µ, ì¢…ê·¼ë‹¹ ë£¨í…Œì¸ ì˜¤ë©”ê°€3, ì´ë„ˆí”Œë¡œë¼ 3ê°œ, í…Œí¬ 8L, í‚¤ì¹œíƒ€ì˜¬ 140ë§¤, ë½í† í• ìŠ¬ë¦¼ 6í†µ, ë½í† í• ë‹¹ì¼€ì–´

        // í•œ ì•„ì´ë””ì— ëª°ì•„ì£¼ëŠ” ìƒí’ˆ (ê°€ëŠ¥í•œ í•œ ì‚¬ëŒì—ê²Œ ìµœëŒ€ì¹˜ê¹Œì§€)
        const CONSOLIDATE_PRODUCTS = [27, 22]; // í‚¤ì¹œíƒ€ì˜¬ 140ë§¤, í…Œí¬ 8L

        const MAX_SAME_PRODUCT = 3; // ì¼ë°˜ ìƒí’ˆ ìµœëŒ€ êµ¬ë§¤ ê°œìˆ˜
        const MAX_UNLIMITED_PRODUCT = 10; // ë¬´ì œí•œ ìƒí’ˆ ìµœëŒ€ êµ¬ë§¤ ê°œìˆ˜

        // tier íŒì • í•¨ìˆ˜ - ì ˆëŒ€ ë³€ê²½ ê¸ˆì§€!
        function getTier(total) {
            if (total >= 500000 && total <= 515000) return TARGET_TIERS[0]; // 50ë§Œ
            if (total >= 400000 && total <= 415000) return TARGET_TIERS[1]; // 40ë§Œ
            if (total >= 300000 && total <= 315000) return TARGET_TIERS[2]; // 30ë§Œ
            return { name: 'ë¯¸ë‹¬', class: 'tier-under' };
        }

        // ê·¸ë£¹ ë¶„ë¥˜: ë£¨ì§€ì•„ ë°°ì • ì—¬ë¶€ì— ë”°ë¼ ê·¸ë£¹ A/B ë¶„ë¥˜
        function classifyGroups(results, lugiaStock) {
            // ë£¨ì§€ì•„ ìˆëŠ” ê·¸ë£¹ A vs ì—†ëŠ” ê·¸ë£¹ B
            const groupA = results.slice(0, Math.min(lugiaStock, results.length));
            const groupB = results.slice(Math.min(lugiaStock, results.length));
            return { groupA, groupB };
        }

        // Greedy ì ‘ê·¼: ê³ ê°€ ìƒí’ˆ ìš°ì„ ìœ¼ë¡œ ëª©í‘œ ê·¼ì²˜ê¹Œì§€
        function greedyApproach(result, maxAllowed, stockRemaining) {
            const items = [];
            let sum = 0;

            // ê°€ê²© ë†’ì€ ìˆœ ì •ë ¬ (ë¹¨ë¦¬ ì±„ìš°ê¸°)
            const available = products
                .filter(p => {
                    if (p.required) return false;
                    if (p.price <= 0 || stockRemaining[p.id] <= 0) return false;
                    const qty = result.productCounts[p.id] || 0;
                    if (LIMITED_PRODUCTS.includes(p.id)) return qty < 1;
                    if (UNLIMITED_PRODUCTS.includes(p.id)) return qty < MAX_UNLIMITED_PRODUCT;
                    return qty < MAX_SAME_PRODUCT;
                })
                .sort((a, b) => b.price - a.price);

            for (const product of available) {
                if (sum + product.price <= maxAllowed) {
                    items.push({ ...product });
                    sum += product.price;
                }
            }

            return { items, sum };
        }

        // Backtracking: ì´ˆê³¼ ì‹œ í° ìƒí’ˆ â†’ ì‘ì€ ìƒí’ˆ êµì²´
        function backtrackToFit(items, minNeeded, maxAllowed, result, stockRemaining) {
            const currentSum = items.reduce((s, i) => s + i.price, 0);

            if (currentSum >= minNeeded && currentSum <= maxAllowed) {
                return items;
            }

            // ì´ˆê³¼í•œ ê²½ìš°: ê°€ì¥ ë¹„ì‹¼ ìƒí’ˆë¶€í„° ì œê±°í•˜ê³  ë” ì‘ì€ ìƒí’ˆìœ¼ë¡œ êµì²´ ì‹œë„
            if (currentSum > maxAllowed) {
                // ê°€ê²© ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
                const sortedItems = [...items].sort((a, b) => b.price - a.price);

                for (let i = 0; i < sortedItems.length; i++) {
                    const removed = sortedItems[i];
                    const remaining = sortedItems.filter((_, idx) => idx !== i);
                    const remainingSum = remaining.reduce((s, item) => s + item.price, 0);

                    const needed = minNeeded - remainingSum;
                    const allowed = maxAllowed - remainingSum;

                    if (needed <= 0 && remainingSum <= maxAllowed) {
                        return remaining;
                    }

                    // ì œê±°ëœ ìƒí’ˆë³´ë‹¤ ì‘ì€ ìƒí’ˆë“¤ ì¤‘ ë²”ìœ„ ë‚´ ë§ëŠ” ê²ƒ ì°¾ê¸°
                    const smaller = products
                        .filter(p => {
                            if (p.required) return false;
                            if (p.id === removed.id) return false;
                            if (p.price >= removed.price) return false;
                            if (p.price <= 0 || stockRemaining[p.id] <= 0) return false;
                            if (remaining.find(r => r.id === p.id)) return false;

                            const qty = result.productCounts[p.id] || 0;
                            if (LIMITED_PRODUCTS.includes(p.id)) return qty < 1;
                            if (UNLIMITED_PRODUCTS.includes(p.id)) return qty < MAX_UNLIMITED_PRODUCT;
                            return qty < MAX_SAME_PRODUCT;
                        })
                        .filter(p => p.price >= needed && p.price <= allowed)
                        .sort((a, b) => b.price - a.price);

                    if (smaller.length > 0) {
                        return [...remaining, smaller[0]];
                    }

                    // ë‘ ê°œ ì¡°í•©ìœ¼ë¡œ ì‹œë„
                    const smallerAll = products
                        .filter(p => {
                            if (p.required) return false;
                            if (p.price >= removed.price) return false;
                            if (p.price <= 0 || stockRemaining[p.id] <= 0) return false;
                            if (remaining.find(r => r.id === p.id)) return false;

                            const qty = result.productCounts[p.id] || 0;
                            if (LIMITED_PRODUCTS.includes(p.id)) return qty < 1;
                            if (UNLIMITED_PRODUCTS.includes(p.id)) return qty < MAX_UNLIMITED_PRODUCT;
                            return qty < MAX_SAME_PRODUCT;
                        })
                        .sort((a, b) => b.price - a.price);

                    for (let j = 0; j < smallerAll.length; j++) {
                        for (let k = j + 1; k < smallerAll.length; k++) {
                            const combo = smallerAll[j].price + smallerAll[k].price;
                            if (combo >= needed && combo <= allowed) {
                                return [...remaining, smallerAll[j], smallerAll[k]];
                            }
                        }
                    }
                }
            }

            return null;
        }

        // ê°œì„ ëœ ì¡°í•© ì°¾ê¸°: Greedy + Backtracking
        function findCombinationWithBacktrack(result, minNeeded, maxAllowed, stockRemaining) {
            if (minNeeded <= 0) return [];
            if (maxAllowed < 0) return null;

            // 1. Greedy ì‹œë„
            const greedyResult = greedyApproach(result, maxAllowed, stockRemaining);

            // 2. ëª©í‘œ ë²”ìœ„ ë‹¬ì„± í™•ì¸
            if (greedyResult.sum >= minNeeded && greedyResult.sum <= maxAllowed) {
                return greedyResult.items;
            }

            // 3. ì´ˆê³¼ ì‹œ Backtracking
            if (greedyResult.sum > maxAllowed || greedyResult.sum < minNeeded) {
                const backtracked = backtrackToFit(greedyResult.items, minNeeded, maxAllowed, result, stockRemaining);
                if (backtracked) return backtracked;
            }

            // 4. ê¸°ì¡´ DP ë°©ì‹ìœ¼ë¡œ fallback
            return findTierCombination(result, minNeeded, maxAllowed, stockRemaining);
        }

        // ë¶„ë°° ì‹¤í–‰ - ìµœëŒ€ ì¶©ì¡± ì „ëµ: ë¼ìš´ë“œ ë¡œë¹ˆ + ë‹¬ì„± ê°€ëŠ¥ì„± ì ìˆ˜ ê¸°ë°˜
        function runDistribution() {
            products.forEach(p => updateProduct(p.id));

            const selectedPersons = getSelectedPersons();
            if (selectedPersons.length === 0) {
                alert('ìµœì†Œ 1ëª… ì´ìƒ ì„ íƒí•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì¬ê³  ë³µì‚¬ (ìœ„íƒ + ì‚¬ì… = ì´ ì¬ê³ )
            let stockRemaining = {};
            let buyStockInfo = {};
            products.forEach(p => {
                stockRemaining[p.id] = p.stock + p.buyStock;
                buyStockInfo[p.id] = p.buyStock;
            });

            console.log(`=== ë¶„ë°° ì‹œì‘: ${selectedPersons.length}ëª… ===`);

            // 1. ëª¨ë“  ì•„ì´ë””ì— ë¹ˆ ê²°ê³¼ ìƒì„±
            const finalResults = selectedPersons.map(name => ({
                personName: name,
                items: [],
                total: 0,
                tier: null,
                productCounts: {}
            }));

            // 2. í•„ìˆ˜ ìƒí’ˆ ë°°ì • (ì¬ê³  ìˆëŠ” ë§Œí¼ë§Œ)
            const requiredProducts = [
                { id: 1, name: 'ë½í† í• ê³¨ë“œ 6í†µ' },
                { id: 2, name: 'ë£¨ì§€ì•„ 6ë°•ìŠ¤' },
                { id: 9, name: 'ë½í† í• ê³¨ë“œ 10í†µ' }
            ];

            for (const req of requiredProducts) {
                const product = products.find(p => p.id === req.id);
                if (!product || stockRemaining[req.id] <= 0) continue;

                // ê¸ˆì•¡ ë‚®ì€ ìˆœìœ¼ë¡œ ë°°ì •
                const sortedResults = [...finalResults].sort((a, b) => a.total - b.total);
                for (const result of sortedResults) {
                    if (stockRemaining[req.id] <= 0) break;
                    if (result.productCounts[req.id]) continue; // ì´ë¯¸ ë°°ì •ë¨

                    result.items.push({ ...product, qty: 1 });
                    result.total += product.price;
                    result.productCounts[req.id] = 1;
                    stockRemaining[req.id]--;
                }
            }

            // 3. ë‹¬ì„± ê°€ëŠ¥ì„± ì ìˆ˜ ê³„ì‚° í•¨ìˆ˜
            function calculateFeasibilityScore(result, tierMin, tierMax, stock) {
                const needed = tierMin - result.total;
                const maxAllowed = tierMax - result.total;

                if (needed <= 0) return { score: 100, combo: [] }; // ì´ë¯¸ ë‹¬ì„±
                if (maxAllowed < 0) return { score: -1, combo: null }; // ë¶ˆê°€ëŠ¥

                // ì‚¬ìš© ê°€ëŠ¥í•œ ìƒí’ˆë“¤ì˜ ì´ ê°€ê²© ê³„ì‚°
                let availableSum = 0;
                const availableProducts = products.filter(p => {
                    if (p.required) return false;
                    if (p.price <= 0 || stock[p.id] <= 0) return false;
                    const qty = result.productCounts[p.id] || 0;
                    if (LIMITED_PRODUCTS.includes(p.id)) return qty < 1;
                    if (UNLIMITED_PRODUCTS.includes(p.id)) return qty < MAX_UNLIMITED_PRODUCT;
                    return qty < MAX_SAME_PRODUCT;
                });

                availableProducts.forEach(p => {
                    const qty = result.productCounts[p.id] || 0;
                    let maxQty = MAX_SAME_PRODUCT;
                    if (LIMITED_PRODUCTS.includes(p.id)) maxQty = 1;
                    if (UNLIMITED_PRODUCTS.includes(p.id)) maxQty = MAX_UNLIMITED_PRODUCT;
                    const canAdd = Math.min(stock[p.id], maxQty - qty);
                    availableSum += p.price * canAdd;
                });

                if (availableSum < needed) return { score: -1, combo: null }; // ì¬ê³  ë¶€ì¡±

                // ì‹¤ì œ ì¡°í•© ì°¾ê¸° ì‹œë„
                const combo = findCombinationWithBacktrack(result, needed, maxAllowed, stock);
                if (combo && combo.length > 0) {
                    // ì ìˆ˜: 100 - (í•„ìš”ê¸ˆì•¡ / 10000) â†’ ì ê²Œ í•„ìš”í• ìˆ˜ë¡ ë†’ì€ ì ìˆ˜
                    return { score: 100 - (needed / 10000), combo };
                }

                return { score: -1, combo: null };
            }

            // 4. ëª¨ë“  tierì— ëŒ€í•´ ë‹¬ì„± ê°€ëŠ¥í•œ ì‚¬ëŒ ì°¾ê¸° ë° ë°°ì • (ë¼ìš´ë“œ ë¡œë¹ˆ)
            const TIER_TARGETS = [
                { min: 300000, max: 315000, name: '30ë§Œ' },
                { min: 400000, max: 415000, name: '40ë§Œ' },
                { min: 500000, max: 515000, name: '50ë§Œ' }
            ];

            console.log('=== Phase 1: ìµœì  tier ë°°ì • (ë¼ìš´ë“œ ë¡œë¹ˆ) ===');

            let totalAssigned = 0;
            let maxIterations = selectedPersons.length * 3; // ë¬´í•œ ë£¨í”„ ë°©ì§€
            let iteration = 0;

            while (iteration < maxIterations) {
                iteration++;
                let assignedThisRound = false;

                // ë¯¸ë‹¬ì¸ ì‚¬ëŒë“¤ ì¤‘ì—ì„œ tier ë‹¬ì„± ê°€ëŠ¥í•œ ì‚¬ëŒ ì°¾ê¸°
                const underResults = finalResults.filter(r => {
                    const tier = getTier(r.total);
                    return tier.name === 'ë¯¸ë‹¬';
                });

                if (underResults.length === 0) break;

                // ê° ì‚¬ëŒë³„ë¡œ ë‹¬ì„± ê°€ëŠ¥í•œ ìµœì € tierì™€ ì ìˆ˜ ê³„ì‚° (30ë§Œ ìš°ì„  - ìµœëŒ€ ì¶©ì¡± ì „ëµ)
                const candidates = [];
                for (const result of underResults) {
                    // ë‚®ì€ tierë¶€í„° ì‹œë„ (30ë§Œ â†’ 40ë§Œ â†’ 50ë§Œ) - ìµœëŒ€ ì¶©ì¡± ì „ëµ
                    for (let i = 0; i < TIER_TARGETS.length; i++) {
                        const tier = TIER_TARGETS[i];
                        const { score, combo } = calculateFeasibilityScore(
                            result, tier.min, tier.max, stockRemaining
                        );

                        if (score > 0 && combo && combo.length > 0) {
                            candidates.push({
                                result,
                                tier,
                                score: score - (i * 10), // ë‚®ì€ tier ë³´ë„ˆìŠ¤ (30ë§Œ ìš°ì„ )
                                combo
                            });
                            break; // ë‹¬ì„± ê°€ëŠ¥í•œ ìµœì € tier ì°¾ìŒ
                        }
                    }
                }

                if (candidates.length === 0) break;

                // ì ìˆ˜ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬ (ë‹¬ì„± ì‰¬ìš´ ì‚¬ëŒ ìš°ì„ )
                candidates.sort((a, b) => b.score - a.score);

                // ìƒìœ„ 1ëª…ì—ê²Œ ë°°ì • (ë¼ìš´ë“œ ë¡œë¹ˆ íš¨ê³¼)
                const best = candidates[0];
                applyCombo(best.result, best.combo, stockRemaining);
                console.log(`${best.result.personName}: ${best.tier.name} tier ë‹¬ì„± (${best.result.total.toLocaleString()}ì›) [ì ìˆ˜: ${best.score.toFixed(1)}]`);
                totalAssigned++;
                assignedThisRound = true;

                if (!assignedThisRound) break;
            }

            console.log(`=== Phase 1 ì™„ë£Œ: ${totalAssigned}ëª… tier ë‹¬ì„± ===`);

            // 5. ìŠ¹ê²© ì‹œë„ (30ë§Œ â†’ 40ë§Œ â†’ 50ë§Œ)
            console.log('=== Phase 2: tier ìŠ¹ê²© ì‹œë„ ===');

            let improved = true;
            while (improved) {
                improved = false;

                // 30ë§Œ â†’ 40ë§Œ ìŠ¹ê²©
                const tier30 = finalResults.filter(r => r.total >= 300000 && r.total <= 315000);
                for (const result of tier30) {
                    const { score, combo } = calculateFeasibilityScore(
                        result, 400000, 415000, stockRemaining
                    );
                    if (score > 0 && combo && combo.length > 0) {
                        applyCombo(result, combo, stockRemaining);
                        console.log(`${result.personName}: 30ë§Œ â†’ 40ë§Œ ìŠ¹ê²© (${result.total.toLocaleString()}ì›)`);
                        improved = true;
                        break;
                    }
                }

                // 40ë§Œ â†’ 50ë§Œ ìŠ¹ê²©
                const tier40 = finalResults.filter(r => r.total >= 400000 && r.total <= 415000);
                for (const result of tier40) {
                    const { score, combo } = calculateFeasibilityScore(
                        result, 500000, 515000, stockRemaining
                    );
                    if (score > 0 && combo && combo.length > 0) {
                        applyCombo(result, combo, stockRemaining);
                        console.log(`${result.personName}: 40ë§Œ â†’ 50ë§Œ ìŠ¹ê²© (${result.total.toLocaleString()}ì›)`);
                        improved = true;
                        break;
                    }
                }
            }

            // 6. ë¯¸ë‹¬ ì•„ì´ë””: ë§ˆì§€ë§‰ìœ¼ë¡œ í•œë²ˆ ë” tier ì‹œë„ + Greedy ì±„ì›€
            console.log('=== Phase 3: ë¯¸ë‹¬ ì•„ì´ë”” ìµœì¢… ì²˜ë¦¬ ===');
            const MAX_TOTAL = 515000;
            const finalUnderResults = finalResults.filter(r => {
                const tier = getTier(r.total);
                return tier.name === 'ë¯¸ë‹¬';
            });

            for (const result of finalUnderResults) {
                // ëª¨ë“  tier ë‹¤ì‹œ ì‹œë„
                let tierAchieved = false;
                for (const tier of TIER_TARGETS) {
                    const { score, combo } = calculateFeasibilityScore(
                        result, tier.min, tier.max, stockRemaining
                    );
                    if (score > 0 && combo && combo.length > 0) {
                        applyCombo(result, combo, stockRemaining);
                        console.log(`${result.personName}: ${tier.name} tier ë‹¬ì„± (${result.total.toLocaleString()}ì›)`);
                        tierAchieved = true;
                        break;
                    }
                }

                // tier ë‹¬ì„± ì‹¤íŒ¨ â†’ Greedyë¡œ ìµœëŒ€í•œ ì±„ì›€ (ìƒí•œ 515k)
                if (!tierAchieved) {
                    greedyFillWithLimit(result, stockRemaining, MAX_TOTAL);
                    console.log(`${result.personName}: Greedy ì±„ì›€ (${result.total.toLocaleString()}ì›) - ë¯¸ë‹¬`);
                }
            }

            // 7. tier íŒì •
            finalResults.forEach(r => {
                r.tier = getTier(r.total);
            });

            // í†µê³„ ì¶œë ¥
            const tier50Count = finalResults.filter(r => r.tier?.name === '50ë§Œ').length;
            const tier40Count = finalResults.filter(r => r.tier?.name === '40ë§Œ').length;
            const tier30Count = finalResults.filter(r => r.tier?.name === '30ë§Œ').length;
            const underCount = finalResults.filter(r => r.tier?.name === 'ë¯¸ë‹¬').length;
            console.log(`=== ìµœì¢… ê²°ê³¼: 50ë§Œ ${tier50Count}ëª…, 40ë§Œ ${tier40Count}ëª…, 30ë§Œ ${tier30Count}ëª…, ë¯¸ë‹¬ ${underCount}ëª… ===`);
            console.log(`=== ì¶©ì¡±ë¥ : ${((selectedPersons.length - underCount) / selectedPersons.length * 100).toFixed(1)}% ===`);

            // ì‚¬ì… í•­ëª© ê³„ì‚°
            const buyAssignments = calculateBuyAssignments(finalResults, buyStockInfo);

            displayResults(finalResults, stockRemaining, buyAssignments);
            saveDistributionResults(finalResults, stockRemaining, buyAssignments);
            saveToLocalStorageSilent();
        }

        // ì¡°í•© ì ìš© í—¬í¼ í•¨ìˆ˜
        function applyCombo(result, combo, stockRemaining) {
            combo.forEach(item => {
                const existing = result.items.find(x => x.id === item.id);
                if (existing) {
                    existing.qty++;
                } else {
                    result.items.push({ ...item, qty: 1 });
                }
                result.total += item.price;
                result.productCounts[item.id] = (result.productCounts[item.id] || 0) + 1;
                stockRemaining[item.id]--;
            });
        }

        // Greedy ì±„ì›€ (ìƒí•œ ì œí•œ ìˆìŒ)
        function greedyFillWithLimit(result, stockRemaining, maxTotal) {
            let changed = true;
            while (changed) {
                changed = false;

                // ê°€ê²© ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬ (ë¹¨ë¦¬ ì±„ìš°ê¸°)
                const available = products
                    .filter(p => {
                        if (p.required) return false;
                        if (p.price <= 0 || stockRemaining[p.id] <= 0) return false;
                        if (result.total + p.price > maxTotal) return false;

                        const qty = result.productCounts[p.id] || 0;
                        if (LIMITED_PRODUCTS.includes(p.id)) return qty < 1;
                        if (UNLIMITED_PRODUCTS.includes(p.id)) return qty < MAX_UNLIMITED_PRODUCT;
                        return qty < MAX_SAME_PRODUCT;
                    })
                    .sort((a, b) => b.price - a.price);

                if (available.length > 0) {
                    const product = available[0];
                    const existing = result.items.find(x => x.id === product.id);
                    if (existing) {
                        existing.qty++;
                    } else {
                        result.items.push({ ...product, qty: 1 });
                    }
                    result.total += product.price;
                    result.productCounts[product.id] = (result.productCounts[product.id] || 0) + 1;
                    stockRemaining[product.id]--;
                    changed = true;
                }
            }
        }

        // DP ê¸°ë°˜ tier ì¡°í•© ì°¾ê¸°
        function findTierCombination(result, minNeeded, maxAllowed, stockRemaining) {
            if (minNeeded <= 0) return [];
            if (maxAllowed < 0) return null;

            // ì‚¬ìš© ê°€ëŠ¥í•œ ìƒí’ˆ ëª©ë¡ ë§Œë“¤ê¸° (ì¬ê³  ìˆê³ , ì œí•œ ë‚´)
            const availableItems = [];
            products.forEach(p => {
                if (p.required) return;
                if (p.price <= 0 || stockRemaining[p.id] <= 0) return;

                const currentQty = result.productCounts[p.id] || 0;
                let maxQty = MAX_SAME_PRODUCT;
                if (LIMITED_PRODUCTS.includes(p.id)) maxQty = 1;
                if (UNLIMITED_PRODUCTS.includes(p.id)) maxQty = MAX_UNLIMITED_PRODUCT;

                const canAdd = Math.min(stockRemaining[p.id], maxQty - currentQty);
                for (let i = 0; i < canAdd; i++) {
                    availableItems.push({ ...p });
                }
            });

            if (availableItems.length === 0) return null;

            // DP: dp[ê¸ˆì•¡] = í•´ë‹¹ ê¸ˆì•¡ì„ ë§Œë“¤ê¸° ìœ„í•œ ì•„ì´í…œ ì¸ë±ìŠ¤ ë°°ì—´
            const dp = new Map();
            dp.set(0, []);

            for (let i = 0; i < availableItems.length; i++) {
                const item = availableItems[i];
                const price = item.price;

                // ì—­ìˆœìœ¼ë¡œ ìˆœíšŒí•´ì„œ ê°™ì€ ì•„ì´í…œ ì¤‘ë³µ ì‚¬ìš© ë°©ì§€
                const entries = Array.from(dp.entries()).sort((a, b) => b[0] - a[0]);

                for (const [currentSum, indices] of entries) {
                    const newSum = currentSum + price;
                    if (newSum > maxAllowed) continue;
                    if (dp.has(newSum)) continue;

                    dp.set(newSum, [...indices, i]);

                    // ëª©í‘œ ë²”ìœ„ ë„ë‹¬ ì‹œ ë°”ë¡œ ë°˜í™˜
                    if (newSum >= minNeeded && newSum <= maxAllowed) {
                        const resultIndices = dp.get(newSum);
                        return resultIndices.map(idx => availableItems[idx]);
                    }
                }
            }

            // DP ì™„ë£Œ í›„ ëª©í‘œ ë²”ìœ„ ë‚´ ê¸ˆì•¡ ì°¾ê¸°
            for (let target = minNeeded; target <= maxAllowed; target++) {
                if (dp.has(target)) {
                    const resultIndices = dp.get(target);
                    return resultIndices.map(idx => availableItems[idx]);
                }
            }

            return null;
        }

        // ì‚¬ì… í•­ëª© ê³„ì‚° - ìƒí’ˆë³„ë¡œ 5ë§Œì› ì´ìƒ ë˜ë„ë¡ í•œ ì•„ì´ë””ì— ëª°ì•„ì£¼ê¸°
        const MIN_BUY_AMOUNT = 50000; // ì‚¬ì… ìµœì†Œ ê¸ˆì•¡

        function calculateBuyAssignments(results, buyStockInfo) {
            // 1. ê° ì•„ì´ë””ê°€ ì–´ë–¤ ìƒí’ˆì„ ëª‡ ê°œ ê°€ì§€ê³  ìˆëŠ”ì§€ ë§¤í•‘
            const personProducts = {}; // { personIndex: { productId: qty, ... } }

            results.forEach((result, personIndex) => {
                personProducts[personIndex] = {};
                result.items.forEach(item => {
                    personProducts[personIndex][item.id] = item.qty;
                });
            });

            // 2. ì‚¬ì… ë°°ì • ê²°ê³¼
            const buyAssignments = {}; // { personIndex: { productId: buyQty, ... } }

            // 3. ë‚¨ì€ ì‚¬ì… ì¬ê³  ë³µì‚¬
            const remainingBuyStock = { ...buyStockInfo };

            // 4. ìƒí’ˆë³„ë¡œ ì²˜ë¦¬
            const productsWithBuyStock = products
                .filter(p => remainingBuyStock[p.id] > 0)
                .sort((a, b) => b.price - a.price);

            for (const product of productsWithBuyStock) {
                const productId = product.id;
                let buyStockLeft = remainingBuyStock[productId];
                if (buyStockLeft <= 0) continue;

                // ì´ ìƒí’ˆ 1ê°œê°€ 5ë§Œì› ì´ìƒì¸ì§€ í™•ì¸
                const needsGrouping = product.price < MIN_BUY_AMOUNT;
                // 5ë§Œì› ì±„ìš°ë ¤ë©´ ëª‡ ê°œ í•„ìš”í•œì§€
                const minQtyFor50k = needsGrouping ? Math.ceil(MIN_BUY_AMOUNT / product.price) : 1;

                // ì´ ìƒí’ˆì„ ê°€ì§„ ì•„ì´ë””ë“¤ ì°¾ê¸° (ë’¤ì—ì„œë¶€í„°)
                const personsWithProduct = [];
                results.forEach((result, personIndex) => {
                    const qty = personProducts[personIndex][productId] || 0;
                    if (qty > 0) {
                        personsWithProduct.push({ personIndex, qty });
                    }
                });
                personsWithProduct.reverse();

                // 5ë§Œì› ë¯¸ë§Œ ìƒí’ˆ: í•œ ì•„ì´ë””ì— 5ë§Œì› ì´ìƒ ë˜ë„ë¡ ëª°ì•„ì£¼ê¸°
                if (needsGrouping) {
                    for (const { personIndex, qty } of personsWithProduct) {
                        if (buyStockLeft <= 0) break;

                        const alreadyAssigned = buyAssignments[personIndex]?.[productId] || 0;
                        const canAssign = Math.min(qty - alreadyAssigned, buyStockLeft);

                        // 5ë§Œì› ì±„ìš¸ ìˆ˜ ìˆëŠ” ê°œìˆ˜ê°€ ìˆì„ ë•Œë§Œ ë°°ì •
                        if (canAssign >= minQtyFor50k) {
                            // 5ë§Œì› ì´ìƒ ë˜ëŠ” ìµœì†Œ ê°œìˆ˜ë§Œ ë°°ì • (ë‚˜ë¨¸ì§€ëŠ” ë‹¤ë¥¸ ì•„ì´ë””ì—)
                            const toAssign = minQtyFor50k;

                            if (!buyAssignments[personIndex]) {
                                buyAssignments[personIndex] = {};
                            }
                            buyAssignments[personIndex][productId] = toAssign;
                            buyStockLeft -= toAssign;
                        }
                    }

                    // ë‚¨ì€ ì‚¬ì… ì¬ê³  ì²˜ë¦¬ (5ë§Œì› ëª» ì±„ìš°ë”ë¼ë„ ë°°ì •)
                    if (buyStockLeft > 0) {
                        for (const { personIndex, qty } of personsWithProduct) {
                            if (buyStockLeft <= 0) break;

                            const alreadyAssigned = buyAssignments[personIndex]?.[productId] || 0;
                            const canAssign = Math.min(qty - alreadyAssigned, buyStockLeft);

                            if (canAssign > 0) {
                                if (!buyAssignments[personIndex]) {
                                    buyAssignments[personIndex] = {};
                                }
                                buyAssignments[personIndex][productId] = (buyAssignments[personIndex][productId] || 0) + canAssign;
                                buyStockLeft -= canAssign;
                            }
                        }
                    }
                } else {
                    // 5ë§Œì› ì´ìƒ ìƒí’ˆ: ê¸°ì¡´ì²˜ëŸ¼ ë’¤ì—ì„œë¶€í„° 1ê°œì”© ë°°ì •
                    for (const { personIndex, qty } of personsWithProduct) {
                        if (buyStockLeft <= 0) break;

                        const alreadyAssigned = buyAssignments[personIndex]?.[productId] || 0;
                        const canAssign = Math.min(qty - alreadyAssigned, buyStockLeft);

                        if (canAssign > 0) {
                            if (!buyAssignments[personIndex]) {
                                buyAssignments[personIndex] = {};
                            }
                            buyAssignments[personIndex][productId] = canAssign;
                            buyStockLeft -= canAssign;
                        }
                    }
                }
            }

            return buyAssignments;
        }

        // ê²°ê³¼ í‘œì‹œ
        function displayResults(results, stockRemaining, buyAssignments = {}) {
            const section = document.getElementById('resultsSection');
            section.style.display = 'block';

            // ìš”ì•½
            const summary = document.getElementById('summary');
            const tier50 = results.filter(r => r.tier?.name === '50ë§Œ').length;
            const tier40 = results.filter(r => r.tier?.name === '40ë§Œ').length;
            const tier30 = results.filter(r => r.tier?.name === '30ë§Œ').length;
            const tierUnder = results.filter(r => r.tier?.name === 'ë¯¸ë‹¬' || r.tier?.name === '5ë§Œ ë¯¸ë§Œ').length;
            const totalAmount = results.reduce((sum, r) => sum + r.total, 0);

            summary.innerHTML = `
                <div class="summary-item"><strong>${tier50}ëª…</strong>50ë§Œì›ëŒ€</div>
                <div class="summary-item"><strong>${tier40}ëª…</strong>40ë§Œì›ëŒ€</div>
                <div class="summary-item"><strong>${tier30}ëª…</strong>30ë§Œì›ëŒ€</div>
                <div class="summary-item"><strong>${tierUnder}ëª…</strong>ë¯¸ë‹¬</div>
                <div class="summary-item"><strong>${totalAmount.toLocaleString()}ì›</strong>ì´ ì£¼ë¬¸ê¸ˆì•¡</div>
            `;

            // ê°œì¸ë³„ ê²°ê³¼
            const grid = document.getElementById('resultsGrid');
            grid.innerHTML = '';

            results.forEach((result, personIndex) => {
                const card = document.createElement('div');
                card.className = `person-card ${result.tier?.class || ''}`;
                card.id = `card_${personIndex}`;

                // ì´ ì‚¬ëŒì˜ ì‚¬ì… í•­ëª© ê°€ì ¸ì˜¤ê¸°
                const personBuyItems = buyAssignments[personIndex] || {};
                const hasBuyItems = Object.keys(personBuyItems).length > 0;

                // ìœ„íƒ í•­ëª©ê³¼ ì‚¬ì… í•­ëª© ë¶„ë¦¬
                let consignmentItems = []; // ìœ„íƒ
                let buyItems = []; // ì‚¬ì…

                result.items.forEach(item => {
                    const buyQty = personBuyItems[item.id] || 0;
                    const consignmentQty = item.qty - buyQty;

                    if (consignmentQty > 0) {
                        consignmentItems.push({ ...item, qty: consignmentQty });
                    }
                    if (buyQty > 0) {
                        buyItems.push({ ...item, qty: buyQty });
                    }
                });

                // ì´ ì²´í¬ë°•ìŠ¤ ê°œìˆ˜ (ìœ„íƒ + ì‚¬ì…)
                const totalCheckboxCount = consignmentItems.length + buyItems.length;
                card.dataset.itemCount = totalCheckboxCount;

                // ìœ„íƒ í•­ëª© HTML
                let itemIndex = 0;
                const consignmentHtml = consignmentItems.map((item) => {
                    const itemId = `order_${personIndex}_${itemIndex++}`;
                    return `<li id="${itemId}_li">
                        <div class="item-info">
                            <div class="order-check" id="${itemId}" onclick="toggleOrder(${personIndex}, '${itemId}')" title="ì£¼ë¬¸ ì™„ë£Œ ì²´í¬"></div>
                            <span class="item-name">${item.name}${item.qty > 1 ? ` x${item.qty}` : ''}</span>
                        </div>
                        <span>${(item.price * item.qty).toLocaleString()}ì›</span>
                    </li>`;
                }).join('');

                // ì‚¬ì… í•­ëª© HTML
                const buyHtml = buyItems.map((item) => {
                    const itemId = `order_${personIndex}_${itemIndex++}`;
                    return `<li id="${itemId}_li" class="buy-item">
                        <div class="item-info">
                            <div class="order-check" id="${itemId}" onclick="toggleOrder(${personIndex}, '${itemId}')" title="ì‚¬ì… ì£¼ë¬¸ ì™„ë£Œ ì²´í¬"></div>
                            <span class="item-name">${item.name}${item.qty > 1 ? ` x${item.qty}` : ''}</span>
                        </div>
                        <span>${(item.price * item.qty).toLocaleString()}ì›</span>
                    </li>`;
                }).join('');

                // êµ¬ë¶„ì„  ë° ì‚¬ì… ì„¹ì…˜
                const buySection = hasBuyItems ? `
                    <li class="section-divider">â”€â”€â”€â”€â”€â”€ ğŸ“¦ ì‚¬ì… â”€â”€â”€â”€â”€â”€</li>
                    ${buyHtml}
                ` : '';

                card.innerHTML = `
                    <h3>
                        <span>ğŸ‘¤ ${result.personName}<span class="progress-badge" id="badge_${personIndex}">0/${totalCheckboxCount}</span></span>
                        <span class="total">${result.total.toLocaleString()}ì›</span>
                    </h3>
                    <div style="margin-bottom: 8px; font-weight: 600; color: ${result.tier?.class === 'tier-under' ? '#dc3545' : '#28a745'}">
                        ${result.tier?.name || '-'}
                    </div>
                    <ul>${consignmentHtml || ''}${buySection || (consignmentHtml ? '' : '<li>ë°°ì •ëœ ìƒí’ˆ ì—†ìŒ</li>')}</ul>
                `;
                grid.appendChild(card);
            });

            // ë‚¨ì€ ì¬ê³  í‘œì‹œ
            const remainingStock = products
                .filter(p => stockRemaining[p.id] > 0)
                .map(p => `${p.name}: ${stockRemaining[p.id]}ê°œ`)
                .join(', ');

            if (remainingStock) {
                const stockDiv = document.createElement('div');
                stockDiv.className = 'stock-info';
                stockDiv.style.marginTop = '20px';
                stockDiv.innerHTML = `<strong>ğŸ“¦ ë‚¨ì€ ì¬ê³ :</strong> ${remainingStock}`;
                grid.appendChild(stockDiv);
            }
        }

        // localStorage ì €ì¥
        function saveToLocalStorage() {
            products.forEach(p => updateProduct(p.id));
            const selectedPersons = getSelectedPersons();
            const data = {
                products: products.map(p => ({ id: p.id, price: p.price, stock: p.stock, buyStock: p.buyStock })),
                selectedPersons: selectedPersons
            };
            localStorage.setItem('hyundaimall_fair', JSON.stringify(data));
            alert('ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤!');
        }

        // localStorage ë¶ˆëŸ¬ì˜¤ê¸°
        function loadFromLocalStorage() {
            const saved = localStorage.getItem('hyundaimall_fair');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    if (data.products) {
                        data.products.forEach(savedProduct => {
                            const product = products.find(p => p.id === savedProduct.id);
                            if (product) {
                                product.price = savedProduct.price || 0;
                                product.stock = savedProduct.stock || 0;
                                product.buyStock = savedProduct.buyStock || 0;
                            }
                        });
                    }
                    // ì„ íƒëœ ì¸ì› ë³µì› (renderPersonCheckboxes í›„ì— ì ìš©)
                    if (data.selectedPersons) {
                        window.savedSelectedPersons = data.selectedPersons;
                    }
                } catch (e) {
                    console.error('ì €ì¥ëœ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', e);
                }
            }
        }

        // ì €ì¥ëœ ì¸ì› ì„ íƒ ë³µì›
        function restoreSelectedPersons() {
            if (window.savedSelectedPersons) {
                persons.forEach((name, index) => {
                    const checkbox = document.getElementById(`person_${index}`);
                    const isSelected = window.savedSelectedPersons.includes(name);
                    checkbox.checked = isSelected;
                    if (isSelected) {
                        checkbox.parentElement.classList.add('selected');
                    } else {
                        checkbox.parentElement.classList.remove('selected');
                    }
                });
            }
        }

        // ì´ˆê¸°í™” (ìœ„íƒ + ì‚¬ì… ê°œìˆ˜ ì´ˆê¸°í™”, ë¶„ë°° ê²°ê³¼ëŠ” ìœ ì§€)
        function resetAll() {
            if (confirm('ìœ„íƒ/ì‚¬ì… ê°œìˆ˜ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(ë¶„ë°° ê²°ê³¼ëŠ” ìœ ì§€ë©ë‹ˆë‹¤)')) {
                products.forEach(p => {
                    p.stock = 0;
                    p.buyStock = 0;
                });
                renderProductTable();
                // ê°€ê²© ì •ë³´ëŠ” ìœ ì§€í•˜ê³  ì¬ê³ ë§Œ ì´ˆê¸°í™”í•˜ì—¬ ì €ì¥
                saveToLocalStorageSilent();
            }
        }

        // ë¶„ë°° ê²°ê³¼ ì´ˆê¸°í™” (ê²°ê³¼ ì„¹ì…˜ ìˆ¨ê¸°ê³  ì €ì¥ëœ ë¶„ë°° ë°ì´í„° ì‚­ì œ)
        function clearDistribution() {
            if (confirm('ë¶„ë°° ê²°ê³¼ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                document.getElementById('resultsSection').style.display = 'none';
                document.getElementById('resultsGrid').innerHTML = '';
                document.getElementById('summary').innerHTML = '';
                document.getElementById('distributionTime').textContent = '';
                localStorage.removeItem('hyundaimall_distribution');
                localStorage.removeItem('hyundaimall_ordered');
            }
        }

        // ì¡°ìš©íˆ ì €ì¥ (ì•Œë¦¼ ì—†ì´)
        function saveToLocalStorageSilent() {
            products.forEach(p => updateProduct(p.id));
            const selectedPersons = getSelectedPersons();
            const data = {
                products: products.map(p => ({ id: p.id, price: p.price, stock: p.stock, buyStock: p.buyStock })),
                selectedPersons: selectedPersons
            };
            localStorage.setItem('hyundaimall_fair', JSON.stringify(data));
        }

        // ì¬ê³  ë°ì´í„° ë³µì‚¬ (ìœ„íƒ + ì‚¬ì… + ì„ íƒëœ ì¸ì›)
        function copyStockData() {
            products.forEach(p => updateProduct(p.id));

            // ì¬ê³ ê°€ 0ë³´ë‹¤ í° ìƒí’ˆë§Œ ë³µì‚¬ (ìœ„íƒ ë˜ëŠ” ì‚¬ì…)
            const dataLines = products
                .filter(p => p.stock > 0 || p.buyStock > 0)
                .map(p => `${p.name}\t${p.price}\t${p.stock}\t${p.buyStock}`)
                .join('\n');

            // ì„ íƒëœ ì¸ì› ëª©ë¡ ì¶”ê°€
            const selectedPersons = getSelectedPersons();
            const personsLine = `[ì„ íƒì¸ì›]\t${selectedPersons.join(',')}`;

            const fullData = dataLines + '\n' + personsLine;

            if (!dataLines) {
                alert('ë³µì‚¬í•  ì¬ê³  ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            navigator.clipboard.writeText(fullData).then(() => {
                alert(`ì¬ê³  ë°ì´í„°ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n(ìœ„íƒ/ì‚¬ì… + ì„ íƒì¸ì› ${selectedPersons.length}ëª…)`);
            }).catch(err => {
                // í´ë¦½ë³´ë“œ ì‹¤íŒ¨ ì‹œ ëŒ€ì•ˆ
                const textArea = document.createElement('textarea');
                textArea.value = fullData;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert(`ì¬ê³  ë°ì´í„°ê°€ ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!\n(ìœ„íƒ/ì‚¬ì… + ì„ íƒì¸ì› ${selectedPersons.length}ëª…)`);
            });
        }

        // ë¶™ì—¬ë„£ê¸° ëª¨ë‹¬ ì—´ê¸°
        function showPasteModal() {
            document.getElementById('pasteModal').style.display = 'flex';
            document.getElementById('pasteArea').value = '';
            document.getElementById('pasteArea').focus();
        }

        // ë¶™ì—¬ë„£ê¸° ëª¨ë‹¬ ë‹«ê¸°
        function closePasteModal() {
            document.getElementById('pasteModal').style.display = 'none';
        }

        // ë¶™ì—¬ë„£ì€ ë°ì´í„° ì ìš© (ìœ„íƒ + ì‚¬ì… + ì„ íƒëœ ì¸ì›)
        function applyPastedData() {
            const pasteArea = document.getElementById('pasteArea');
            const data = pasteArea.value.trim();

            if (!data) {
                alert('ë°ì´í„°ë¥¼ ë¶™ì—¬ë„£ê¸° í•´ì£¼ì„¸ìš”.');
                return;
            }

            const lines = data.split('\n');
            let appliedCount = 0;
            let personsApplied = false;

            lines.forEach(line => {
                // íƒ­ ë˜ëŠ” 2ê°œ ì´ìƒ ê³µë°±ì„ êµ¬ë¶„ìë¡œ ì¸ì‹ (Slack ë³µì‚¬ ëŒ€ì‘)
                const parts = line.split(/\t|  +/).map(s => s.trim()).filter(s => s);

                // ì„ íƒëœ ì¸ì› ë¼ì¸ ì²˜ë¦¬
                if (parts[0] === '[ì„ íƒì¸ì›]' && parts[1]) {
                    const selectedNames = parts[1].split(',').map(n => n.trim());
                    persons.forEach((name, index) => {
                        const checkbox = document.getElementById(`person_${index}`);
                        const isSelected = selectedNames.includes(name);
                        checkbox.checked = isSelected;
                        if (isSelected) {
                            checkbox.parentElement.classList.add('selected');
                        } else {
                            checkbox.parentElement.classList.remove('selected');
                        }
                    });
                    personsApplied = true;
                    return;
                }

                // ìƒí’ˆ ë°ì´í„° ì²˜ë¦¬ - ìƒí’ˆëª…ìœ¼ë¡œ ë§¤ì¹­ (ìˆœì„œ ë¬´ê´€)
                if (parts.length >= 2) {
                    const name = parts[0].trim();
                    const product = products.find(p => p.name === name);

                    if (product) {
                        // ìˆ«ìë“¤ ì¶”ì¶œ (ê°€ê²©, ìœ„íƒ, ì‚¬ì…)
                        const numbers = parts.slice(1).map(s => parseInt(s) || 0);
                        if (numbers.length >= 1) product.price = numbers[0];
                        if (numbers.length >= 2) product.stock = numbers[1];
                        if (numbers.length >= 3) product.buyStock = numbers[2];
                        appliedCount++;
                    }
                }
            });

            if (appliedCount > 0 || personsApplied) {
                renderProductTable();
                closePasteModal();
                let msg = `${appliedCount}ê°œ ìƒí’ˆì˜ ì¬ê³  ë°ì´í„°ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                if (personsApplied) {
                    msg += `\nì„ íƒëœ ì¸ì›ë„ ë³µì›ë˜ì—ˆìŠµë‹ˆë‹¤.`;
                }
                alert(msg);
            } else {
                alert('ì ìš©í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.\ní˜•ì‹: ìƒí’ˆëª…[íƒ­]ê°€ê²©[íƒ­]ìœ„íƒ[íƒ­]ì‚¬ì…');
            }
        }

        // ì£¼ë¬¸ ì™„ë£Œ í† ê¸€
        function toggleOrder(personIndex, itemId) {
            const checkbox = document.getElementById(itemId);
            const li = document.getElementById(itemId + '_li');
            const card = document.getElementById(`card_${personIndex}`);
            const badge = document.getElementById(`badge_${personIndex}`);
            const itemCount = parseInt(card.dataset.itemCount);

            if (li.classList.contains('ordered')) {
                li.classList.remove('ordered');
                checkbox.innerHTML = '';
            } else {
                li.classList.add('ordered');
                checkbox.innerHTML = 'âœ“';
            }

            // ì²´í¬ëœ ê°œìˆ˜ ê³„ì‚°
            const checkedCount = card.querySelectorAll('li.ordered').length;

            // ë±ƒì§€ ì—…ë°ì´íŠ¸
            if (checkedCount === itemCount) {
                badge.textContent = 'ì™„ë£Œ!';
                badge.classList.add('done');
                card.classList.add('completed');
            } else {
                badge.textContent = `${checkedCount}/${itemCount}`;
                badge.classList.remove('done');
                card.classList.remove('completed');
            }

            // ì²´í¬ ìƒíƒœ ì €ì¥
            saveOrderStatus();
        }

        // ë¶„ë°° ê²°ê³¼ ì €ì¥
        function saveDistributionResults(results, stockRemaining, buyAssignments = {}) {
            const now = new Date();
            const timeString = formatDistributionTime(now);
            const data = {
                results: results.map(r => ({
                    personName: r.personName,
                    items: r.items,
                    total: r.total,
                    tier: r.tier
                })),
                stockRemaining: stockRemaining,
                buyAssignments: buyAssignments,
                savedAt: now.toISOString(),
                timeString: timeString
            };
            localStorage.setItem('hyundaimall_distribution', JSON.stringify(data));

            // ì‹¤í–‰ ì‹œê°„ í‘œì‹œ
            document.getElementById('distributionTime').textContent = `(${timeString} ì‹¤í–‰)`;
        }

        // ë¶„ë°° ì‹œê°„ í¬ë§·
        function formatDistributionTime(date) {
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const hours = date.getHours();
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const ampm = hours < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„';
            const hour12 = hours % 12 || 12;
            return `${month}/${day} ${ampm} ${hour12}:${minutes}`;
        }

        // ì£¼ë¬¸ ì²´í¬ ìƒíƒœ ì €ì¥
        function saveOrderStatus() {
            const orderedItems = [];
            document.querySelectorAll('li.ordered').forEach(li => {
                orderedItems.push(li.id);
            });
            localStorage.setItem('hyundaimall_ordered', JSON.stringify(orderedItems));
        }

        // ì €ì¥ëœ ë¶„ë°° ê²°ê³¼ ë³µì›
        function restoreDistributionResults() {
            const savedData = localStorage.getItem('hyundaimall_distribution');
            const savedOrdered = localStorage.getItem('hyundaimall_ordered');

            if (savedData) {
                try {
                    const data = JSON.parse(savedData);
                    const orderedItems = savedOrdered ? JSON.parse(savedOrdered) : [];

                    displayResults(data.results, data.stockRemaining, data.buyAssignments || {});

                    // ì‹¤í–‰ ì‹œê°„ ë³µì›
                    if (data.timeString) {
                        document.getElementById('distributionTime').textContent = `(${data.timeString} ì‹¤í–‰)`;
                    } else if (data.savedAt) {
                        // ì´ì „ í˜•ì‹ í˜¸í™˜ (savedAtë§Œ ìˆëŠ” ê²½ìš°)
                        const savedDate = new Date(data.savedAt);
                        document.getElementById('distributionTime').textContent = `(${formatDistributionTime(savedDate)} ì‹¤í–‰)`;
                    }

                    // ì²´í¬ ìƒíƒœ ë³µì›
                    setTimeout(() => {
                        orderedItems.forEach(liId => {
                            const li = document.getElementById(liId);
                            if (li) {
                                li.classList.add('ordered');
                                const checkbox = li.querySelector('.order-check');
                                if (checkbox) checkbox.innerHTML = 'âœ“';
                            }
                        });

                        // ë±ƒì§€ ì—…ë°ì´íŠ¸
                        document.querySelectorAll('.person-card').forEach(card => {
                            const personIndex = card.id.replace('card_', '');
                            const badge = document.getElementById(`badge_${personIndex}`);
                            const itemCount = parseInt(card.dataset.itemCount);
                            const checkedCount = card.querySelectorAll('li.ordered').length;

                            if (checkedCount === itemCount) {
                                badge.textContent = 'ì™„ë£Œ!';
                                badge.classList.add('done');
                                card.classList.add('completed');
                            } else {
                                badge.textContent = `${checkedCount}/${itemCount}`;
                            }
                        });
                    }, 100);
                } catch (e) {
                    console.error('ë¶„ë°° ê²°ê³¼ ë³µì› ì‹¤íŒ¨:', e);
                }
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        init();
        restoreDistributionResults();
    </script>
</body>
</html>
